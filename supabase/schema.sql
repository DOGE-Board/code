-- Create proposals table
CREATE TABLE proposals (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    user_id UUID REFERENCES auth.users NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable Row Level Security (RLS)
ALTER TABLE proposals ENABLE ROW LEVEL SECURITY;

create policy "Anonymous users can view proposals"
  on proposals 
  for select
  to public
  using (true);

-- Create policy for users to insert their own proposals
create policy "Users can create their own proposals"
  on proposals
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- Create policy for users to update their own proposals
create policy "Users can update their own proposals"
  on proposals
  for update
  to authenticated
  using (auth.uid() = user_id);

-- Create policy for users to delete their own proposals
create policy "Users can delete their own proposals"
  on proposals
  for delete
  to authenticated
  using (auth.uid() = user_id);

  
/*
Supabase doesn't allow direct queries to auth.users from the client for security reasons. Instead, you'll need to use the Admin API or create a serverless function/API endpoint to handle this operation.
Here's a more secure approach using Supabase's built-in RLS policies:
Create a new migration to add a function that safely handles user lookup:
*/

-- Function: get_user_info_by_id
CREATE OR REPLACE FUNCTION public.get_user_info_by_id(user_id uuid)
 RETURNS TABLE(id uuid, email text)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT id, name, email
  FROM auth.users 
  WHERE id = user_id;
$function$
-- Triggers using get_user_info_by_id
-- No triggers
    


-- Create proposal_arguments table
CREATE TABLE proposal_arguments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    proposal_id BIGINT REFERENCES proposals(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    argument_type VARCHAR(10) NOT NULL CHECK (argument_type IN ('favor', 'against')),
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(proposal_id, user_id, argument_type)
);

-- Enable RLS
ALTER TABLE proposal_arguments enable row level security;

-- Policies for proposal_arguments
CREATE POLICY "Anyone can view arguments"
    ON proposal_arguments FOR SELECT
    USING (true);

CREATE POLICY "Users can add their arguments"
    ON proposal_arguments FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own arguments"
    ON proposal_arguments FOR UPDATE
    TO authenticated
    USING (auth.uid() = user_id);

    
CREATE POLICY "Users can remove their arguments"
    ON proposal_arguments
    FOR DELETE
    TO authenticated
    USING (auth.uid() = user_id);

-- Create trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_proposal_arguments_updated_at
    BEFORE UPDATE
    ON proposal_arguments
    FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();