-- Create proposals table
CREATE TABLE proposals (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    "favorArguments" TEXT,
    "againstArguments" TEXT,
    user_id UUID REFERENCES auth.users NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable Row Level Security (RLS)
ALTER TABLE proposals ENABLE ROW LEVEL SECURITY;

create policy "Anonymous users can view proposals"
  on proposals 
  for select
  to public
  using (true);

-- Create policy for users to insert their own proposals
create policy "Users can create their own proposals"
  on proposals
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- Create policy for users to update their own proposals
create policy "Users can update their own proposals"
  on proposals
  for update
  to authenticated
  using (auth.uid() = user_id);

-- Create policy for users to delete their own proposals
create policy "Users can delete their own proposals"
  on proposals
  for delete
  to authenticated
  using (auth.uid() = user_id);

-- Create proposal_votes table
CREATE TABLE proposal_votes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    proposal_id BIGINT REFERENCES proposals(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    vote_type VARCHAR(4) NOT NULL CHECK (vote_type IN ('up', 'down')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(proposal_id, user_id)
);

-- Enable RLS
ALTER TABLE proposal_votes ENABLE ROW LEVEL SECURITY;

-- Policies for proposal_votes
CREATE POLICY "Anonymous Users can view all votes"
    ON proposal_votes
    FOR SELECT
    TO public
    USING (true);

CREATE POLICY "Users can vote once per proposal"
    ON proposal_votes
    FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can change their vote"
    ON proposal_votes
    FOR UPDATE
    TO authenticated
    USING (auth.uid() = user_id);

CREATE POLICY "Users can remove their vote"
    ON proposal_votes
    FOR DELETE
    TO authenticated
    USING (auth.uid() = user_id);



create table proposal_comments (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  proposal_id bigint references proposals(id) on delete cascade,
  user_id uuid references auth.users(id) on delete cascade,
  content text not null
);

-- Add RLS policies
alter table proposal_comments enable row level security;

create policy "Anyone can view comments"
  on proposal_comments for select
  using ( true );

create policy "Authenticated users can insert comments"
  on proposal_comments for insert
  with check ( auth.role() = 'authenticated' );


  
/*

Supabase doesn't allow direct queries to auth.users from the client for security reasons. Instead, you'll need to use the Admin API or create a serverless function/API endpoint to handle this operation.
Here's a more secure approach using Supabase's built-in RLS policies:
Create a new migration to add a function that safely handles user lookup:
*/

    -- Function: get_user_info_by_id
    CREATE OR REPLACE FUNCTION public.get_user_info_by_id(user_id uuid)
 RETURNS TABLE(id uuid, email text)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT id, name, email
  FROM auth.users 
  WHERE id = user_id;
$function$

    
    -- Triggers using get_user_info_by_id
    -- No triggers
    